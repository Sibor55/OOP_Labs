# OOP_Labs
Labs on subject Object Oriented Programming 

Лабораторная работа 1 (точки и векторы)

Создать класс Point2d  для хранения положения точки на экране со следующим функционалом:
 - Свойство x: int 
 - Свойство y: int
 - конструктор (x: int, y: int)
 - добавить ограничене на возможное значение свойства 0 <= x <= WIDTH (переменная WIDTH задается обычным числом)  
 - добавить ограничене на возможное значение свойства 0 <= н <= HEIGHT (переменная HEIGHT задается обычным числом)
 - реализовать возможность сравнения объектов на эквивалентность (eq)
 - реализовать строкове представление объекта (str, repr)  

Создать класс Vector2d для хранения вектора на экране со следующим функционалом:
 - Свойство x: int 
 - Свойство y: int
 - конструктор (x: int, y: int)
 - конструктор (start: Point2d, end: Point2d)
 - реализовать доступ к элементам вектора по индексу (getitem, setitem)
 - реализовать возможность итерирования обюъекта (iter, len)
 - реализовать возможность сравнения объектов на эквивалентность (eq)
 - реализовать строкове представление объекта (str, repr)  
 - реализовать получение модуля вектора (abs или отдельны метод)
 - реализовать операции сложения, вычитания, умножения на число, деления на число
 - реализовать операции скалярного, векторного произвдения в виде метода инстанса с одним аргументовм и статического метода (метода класса) с двумя аргументами
 - реализовать опреацию смешанного произведения

Продемонстировать работоспособность реализованных методов


Лабораторная работа 2 (красивая консоль) 

Создать класс для вывода текста в консоль в произвольном месте, произвольным цветом, большим псевдошрифтом.
Вывод цветом осуществляется при помощи управляющих ANSI команд, использовать внешние библиотеки запрещено.
Вывод псевдошрифтом осуществляется путем задания в текстовом файле (формат на ваше усмотрение txt, json,, xml, ...) шаблонов символов 
(достаточно задать шаблоны только букв одного алфавита).
Например, 
   *    ****
 *  *     *
****    *
*    *    *

Класс должен уметь:
  - выводить статитически (python: classmethod) текст в произвольном месте, произвольным цветом (цвет задавать при помощи типа данных перечислитель Enum) произвольным символом
          Например: 
Printer.print(text: str, color: Color, position : Tuple[int, int], symbol: str)
 - создавать экземпляр с фиксированным цветом и позицией для дальнейшего вывода текста в едином стиле с поддержкой возвращения состояния косноли в исходное состояние 
    (поддержка в Python: with, в C#: using, в С++: используйте деструктор)
          Например:
with Printer(color: Color, position : Tuple[int, int], symbol: str) as printer:
       printer.print('text1')
       printer.print('text2')
- использовать произвольный символ для вывода пседотекста (в примере шаблонов используется символ *)

Продемонстировать работу класс как статическим образом, так и с использованием создания экземпляра класса, используя with (using и.т.п.)



Лабораторная работа 3 (Система логирования)

Создать систему логирования, применая композицию (аггрегацию),
с возможностью фильтрации и различных способов вывода информации.
Использовать либо протоколы, либо интерфейсы взависимости от используемого языка программирования.

1. Создать протокол/интерфейс фильров ILogFilter / LogFilterProtocol:
  - match(self, text: str)

2. Создать неколько классов реализующих данный протокол/интерфейс
 - SimpleLogFilter - для фильтрации по вхождению паттерна, задаеваемого текстом, в текст сообщения
 - ReLogFilter - для фильтрации по вхождению паттерна, задаваемого регулярным выражением, в текст сообщения

3. Создать протокол/интерфейс обработчиков ILogHandler / LogHandlerProtocol:
 - handle(self, text: str)

4. Создать неколько классов реализующих данный протокол/интерфейс
 - FileHandler - для записи логов в файл
 - SocketHandler - для отправки логов через сокет
 - ConsoleHandler - для вывода логово в консоль
 - SyslogHandler - для записи логов в системные логи

5. Реализовать класс Logger, который принимает список ILogFilter / LogFilterProtocol и список ILogHandler / LogHandlerProtocol и релизает:
 - log(self, text: str) - которая прогоняет логи через фильтры и отдает обработчикам

6. Продемностировать работы спроектированной системы классов



Лабораторная работа 4 (валидация и автообновление)

Создать, класс позволяющий отслеживать изменения в нем, а также проводить валидацию изменений,
Реализуем паттерн Broadcaster/receiver или observer, симулируем событийное программирование.

1. Создать интерфейс / протокол IPropertyChangedListener / PropertyChangedListenerProtocol
  - on_property_changed(obj: T, property_name) -> None

2. Создать интерфейс / протокол INotifyDataChanged / DataChangedProtocol для отслеживания изменения свойств классов
 - add_property_changed_listener(listener: PropertyChangedListenerProtocol)
 - remove_property_changed_listener(listener: PropertyChangedListenerProtocol)

3. Реализовать класс, поддерживающий INotifyDataChanged / DataChangedProtocol с несколькими свойствами, изменение в каждом из которых приводит к вызову on_property_changed для всех слушателей класса

4. Создать интерфейс / протокол IPropertyChangingListener / PropertyChangingListenerProtocol
  - on_property_changing(obj: T, property_name, old_value, new_value) -> bool

5. Создать интерфейс / протокол INotifyDataChanging / DataChangingProtocol для валидации изменений свойств классов
 - add_property_changing_listener(listener: PropertyChangingListenerProtocol)
 - remove_property_changing_listener(listener: PropertyChangingListenerProtocol)

6. Реализовать класс, поддерживающий INotifyDataChanging / DataChangingProtocol с несколькими свойствами, попутка изменения в каждом из которых приводит к вызову on_property_changing для всех слушателей класса с возможностью недопущения изменений, если валидация не пройдена

7. Создать несколько слушателей DataChangedProtocol и несколько валидаторов DataChangingProtocol и продемонстрировать работу реализованной системы



Лабораторная работа 5 (система авторизации)

Создать систему авторизации и хранения информации о пользователях приложении, не зависящую от
источника данных, поддерживающую автоматическую авторизацию пользователей, реализующую взаимодействие с источником данных
обобщенным образом.

Реализуем через паттерн репозиторий

1. Создать класс User с атрибутами:
    id: int
    name: str
    login: str
    password: str (поле не должно показываться при строковом представлении класс)
    email: str (сделать поле необязательным)
    address: str (сделать поле необязательным)

- Сделать, чтобы коллекция классов User умела сортироваться по полю name.
- Реализовать через dataclass или через аналоги в других языках (C# и Java: record)

2. Создать интерфейс / протокол IDataRepository[T] / DataRepsitoryProtocol[T] для системы CRUD = Create, Read, Update, Delete для произвольного типа данных:
  - get_all(self) -> Sequence[T]
  - get_by_id(self, id: int) -> T | None
  - add(self, item: T) -> None
  - update(self, item: T) -> None
  - delete(self, item: T) -> None

2. Создать интерфейс / протокол IUserRepository ( IDataRepository[User]) / UserRepositoryProtocol (DataRepsitoryProtocol[User]) для взаимодействия с типом данных User
 - get_by_login(self, login: str) -> User | None

3. Создать реализацию  DataRepository[T](IDataRepository[T) / DataRepitoryProtocol[T] supports IDataRepsitoryProtocol[T]
  - Осуществляет хранение данных в файле
  - Можно использовать сторонние сериализаторы (Напр., pickle, json, xml)

4. Создать реализацию UserRepository(IUserRepository) / supports UserRepositoryProtocol на основе DataRepository[T](IDataRepository[T) / DataRepitoryProtocol[T]

5. Создать интерфейс / протокол IAuthService / AuthServiceProtocol
  - sign_in(self, user: User) -> None
  - sign_out(selg, user: User) -> None
  - is_authorized -> bool
  - current_user  -> User

6. Создать реализацию IAuthService / AuthServiceProtocol, которая хранит информацию о текущем пользователе в файле и автоматически авторизует пользователя при повторном заходе в программу в случае наличия соответствующей записи в файле

7. Продемонстрировать работу реализованной системы
 - добавление пользователя
 - редактирование свойств пользователя
 - авторизация пользователя
 - смена текущего пользователя
 - авторматическая авторизация при повторном заходе в программу



 Лабораторная работа 6* (виртуальная клавиатура)

Создать класс виртуальной клавиутуры, которая поддерживает:
- добавление/изменение ассоциации клавиши/комбинации клавиш с командой, которую она выполняет
- откат последней выполненной команды (операция undo)
- возврат последней выполненной команды после выполнения отката (операция redo)
- сохренения добавленных ассоциаций на жесткий диск и восстановление при перезапуске программы

Реализовать класс, используя паттерн Command. При этом реализовать комманды:
- команда, которая печатает символ (сделать класс, который обрабатывает все символы, а не много классов под каждый символ), при этом в случае отмены действия стирает последний выведенный символ 
(можно реализовать курс вправо, напечать пробел, курсор вправо)
- команда, которая симулирует увеличение звука (реальную работу со звуком делать не нужно, а просто выводить информацию в текстовом режиме)
- команда, которая симулирует уменьшение звука (реальную работу со звуком делать не нужно, а просто выводить информацию в текстовом режиме)
- команда, которая симулирует запуск медиа плеера (реальную работу с плеером делать не нужно, а просто выводить информацию в текстовом режиме)
- можно добавить что-то свое

Сделать сохренение состояния клавиатуры, используя паттерм Memento (то есть за сохранение/восстановление ассоциаций должен отвечать отдельный класс, а не класс клавиатуры).
Рекомендую для сохранения использовать формат json (но можно и xml, bson, yaml, и даже для нестандартно мыслящих личностей csv или xslx)

Вывод работы программы сделать либо в консоль либо в текстовый файл в подобном  виде:
CONSOLE:                                                    TEXT FILE:
a                                                                    a
b                                                                    ab
c                                                                    abc
undo                                                             ab
undo                                                             a
redo                                                              ab
ctrl++                                                            volume increased +20%
ctrl+-                                                             volume decreased +20%
ctrl+p                                                           media player launched
d                                                                   abd
undo                                                            ab
undo                                                            media player closed

Работу приложение выводить в текстовый файл и в консоль

То есть у вас будет примерно  следующий набор классов:
Keyboard, KeyCommand, VolumeUpCommand, VolumeDownCommand, MediaPlayerCommand, KeybordStateSaver

Создавать графический интерфейс необходимости нет, но если кто-то хочет, я ничего против не имею...
Обратите внимание, что стирание истории != откат действия назад



Лабораторная работа 7 (внедреж зависимостей)

Написать сервис, который управляет управляет ассоциациями между интерфейсами и классами их реализующими. См. Dependency Injection (Рзавитие концециии фабрики классов)

1. Создать класс инжектор должен поддерживать 
- 3 различных режима жизненного цикла соаздаваемы классов LifeStyle: PerRequest, Scoped, Singleton
- регистрацию зависимости между интерфейсов и классом
 напр: register(self, interface_type, class_type, life_circle)
- возможность передачи дополнительных параметров в конструктор регистрируемого класса
 напр: register(self, interface_type, class_type, life_circle, params)
- используовние в конструкторе регистрируемого интерфейса другие уже зарегистрированные интерфейсы
- метод для возвращаения экземпляра класса по интерфейсу. 
напр: get_instance(self, interface_type) -> class_instance
- В зависимости от ассоциированого LifeStyle get_instance должен работать по-разному:
    PerRequest => возвращает каждй раз новый экзепляр класса
    Scoped => возврващет один и тот же экземпляр внутри Scope (внутри открытой области). Можно реализвать, например через with в python
    Singleton => всегда возвращает один и тот же экзмепляр объекта
- добавить также возможность акссоциации интерфейса  с фабричным методом, возваращающим класс
  напр: register(self, interface_type, fabric_method)

2. Создать  минимум три интерфейса
напр: interface1, interface2, interface3
Под каждый интерфейс создать минимум два класса его поддерживающего с разными LifeCircle
напр: class1_debug(interface1), class1_release(interface1), class2_debug(interface2), class2_release(interface2), class3_debug(interface3), class3_release(interface3)

3. Создать две конфигурации c различными регистрациями реализаций interface1, interface2, interface3

4. Продемнстировать получение экземпляров классов при помощи инжектора и их дальнейшее использование